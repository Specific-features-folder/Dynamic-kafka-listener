# Dynamic-kafka-listener

#### <br>Описание<br>
Необходимо реализовать функциональность по вычитыванию массива конфигураций (кафок + топиков в них) и созданию на основании этого массива kafka listener'ов и kafka template в spring-kafka.
Для подключения нового кластера в сервис необходимо будет лишь добавить ещё один элемент в массиве и перезапустить сервис.
Соответственно создание kafka listener должно быть не в декларативном стиле (через аннотацию @KafkaListener), а в императивном. Ведь сколько кафка слушателей потребуется и для каких брокеров будет понятно только в runtime.

#### <br>Рассмотренные варианты реализации:<br>
1. Для каждой шарды задаётся отдельный конфиг KafkaProperties. Это может быть полезно для более тонкой настройки kafka для каждой шарды  
   (personal-kafka-config-for-each-shard)
2. Задаются общие kafka properties для всех шард. Меньше конфигов, но меньше и гибкости  
   (one-kafka-config-for-all-shards)

#### <br>Причины создания<br>
Такая функциональность может быть полезна в различных ситуациях, например, для объединения идентичных потоков сообщений из разных источников для внешней интеграции.
Например, у вас есть шардированная архитектура, где вы делите нагрузку между разными шардами с их собственными кафками, БД и т.д. 
Так, маршрутизируя входящие запросы на разные шарды вы снижаете нагрузку на каждую БД и получаете большую отказоустойчивость.  
Однако, если у вас есть внешние интеграции, то этой системе придётся интегрироваться с каждой из ваших шард, что неудобно. Во-первых, неудобной получается сама интеграция (ведь вместо 1 интеграции количество ваших интеграций = кол-ву шард). Во-вторых, расширить количество шард, при необходимости также сложнее т.к. нужно будет согласовать добавление новых интеграций во внешних системах и подождать их реализацию.
Вместо этого можно объединять потоки сообщений с разных шард для внешней интеграции, а при получении ответов для шард обратно маршрутизировать их в конкретные шарды.

![shards integration img](Multi_shards_integration.png)


<br>`Реализации разделены по веткам, в main ветку слиты все ветки. Конкретные реализации нужно смотреть по отдельным веткам.`
